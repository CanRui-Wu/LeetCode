21. Merge Two Sorted Lists
简单的构建链表，两个链表从头比较即可，小的那一个取下来，并且向后移动一位，继续比较，注意，像链表这类数据结构，访问指针前一定要确定它不是空指针。

23. Merge k Sorted Lists
21的升级版
我使用的是比较头k个，小的哪一个取下来，并且向后移一位，如果每个链表的长度为n，这样做的时间复杂度为O(nk^2)，因为有n*k个元素，比较需要k次。
可以看到每次比较，实际上更换的元素只是一个而已，因此，我们可以使用堆，每次更换堆顶后调整即可，调整堆的时间复杂度为O(logk)，那么总时间复杂度下降为O(nklogk)。
另一种方法则是使用合并排序的思想，两两合并，从k->k/2->k/4直到1，每次合并的时间与长度相关，因此总共为k/2*(2n)+k/4*(4n)+...+1*(kn) = logk*(kn)，与上述复杂度一样。


148. Sort List
比较困难的一道题目，可以使用快排和归并排序两种方法解题。
快排需要去掉对重复元素的排序才能通过，而且在写代码上，千万不能用两头交换法，因为链表的是单向的，也不宜采用多个交换的方式，如冒泡或是单向交换。
最好的方法是不交换主元素，将比头元素小的元素直接放到链表头，这样主元素指针不用变动，而且当前指针只需要改变它的下一个结点指向下下个即可。
快排的问题在于时间复杂度不稳定，可能达到O(n^2)，而且空间复杂度为O(logn)，不符合题目要求。

如果用归并排序，自顶向下，那么思路还是很明确的，时间复杂度稳定，为O(nlogn),缺点在于同样有栈空间的消耗，空间复杂度O(logn),同样不符合。
先找到链表中间的结点(快指针，慢指针，快的在终点则慢的在中间)，记得保证偶数时指向小的那个。
然后将保存中间结点下一个的指针，并将其置为空，对存的指针和头指针分别调用归并排序并获取返回的头指针。
返回的两个头指针即指向两个排好序的链表，将其合并即可。

自底向上，真正的时间复杂度稳定O(nlogn)，空间复杂度O(1)。
不能用队列，如果用队列同样会很简单，但是空间复杂度O(logn)，实现较复杂，没有实现。


